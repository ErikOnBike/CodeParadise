"
I am the base class for both browser events and synthetic events.
Synthetic events can not be generated by the browser. Synthetic events
are pure Smalltalk events. For custom events, which CAN be used by the
browser, use CpCustomEvent a subclass of CpEvent.

"
Class {
	#name : #CpBaseEvent,
	#superclass : #Object,
	#category : #'CodeParadise-WebApplication-Events'
}

{ #category : #'conditional events' }
CpBaseEvent class >> & aCondition [

	^ self asConditionalEvent & aCondition
]

{ #category : #announcing }
CpBaseEvent class >> , anEvent [

	"Combine the receiver with the specified event.

	For example in:
		aDomElement when: CpKeyUpEvent, CpKeyDownEvent send: #onKey: to: self
	"

	^ AnnouncementSet with: self with: anEvent
]

{ #category : #'conditional events' }
CpBaseEvent class >> addConditionsToDenySpecialsTo: aConditionalEvent [

	"Add condition to specified conditional event which prevents special conditions to be allowed.

	Subclasses should add conditions."

]

{ #category : #announcing }
CpBaseEvent class >> addListenerTo: anElement [

	"Add a browser event listener to the specified element"

	self subclassResponsibility
]

{ #category : #'conditional events' }
CpBaseEvent class >> addListenerTo: anElement withConditions: aCollection [

	"Add a browser event listener to the specified element using the specified conditions.
	By default conditions do not need to be used, because handling the event will check
	for the conditions (see CpConditionalEvent >> #handlesAnnouncement:). In some situations
	the actual JavaScript event handler needs a specific setup. Subclasses should therefore
	override if necessary."

	self addListenerTo: anElement
]

{ #category : #announcing }
CpBaseEvent class >> asAnnouncement [

	^ self new
]

{ #category : #'conditional events' }
CpBaseEvent class >> asConditionalEvent [

	^ CpConditionalEvent eventClass: self
]

{ #category : #announcing }
CpBaseEvent class >> handlesAnnouncement: anAnnouncement [

	"The receiver acts as a filter to determine whether subscribers who used the receiver as signaling tag (event identifier class or symbol)
	should receive incoming announcement. In particular, registering to a superclass will receive the announcements from all subclasses.
	See Announcement >> #handlesAnnouncement:"

	^ anAnnouncement class includesBehavior: self
]

{ #category : #'conditional events' }
CpBaseEvent class >> noModifiers [

	"Answer a ConditionalEvent for the receiver disallowing any modifiers.

	This is useful to specify only a click event is allowed, but no modifier should
	be down when clicked."

	^ self & CpNoModifiersDown
]

{ #category : #'conditional events' }
CpBaseEvent class >> only [

	"Answer an instance of the receiver without any 'special' conditions"

	| conditionalEvent |

	conditionalEvent := self asConditionalEvent.

	self addConditionsToDenySpecialsTo: conditionalEvent.

	^ conditionalEvent
]

{ #category : #announcing }
CpBaseEvent class >> removeListenerFrom: anElement [

	"Remove a browser event listener from the specified element"

	self subclassResponsibility
]

{ #category : #'conditional events' }
CpBaseEvent class >> removeListenerFrom: anElement withConditions: aCollection [

	"Remove a browser event listener from the specified element using the specified conditions.
	By default conditions do not need to be used, because handling the event will check
	for the conditions (see CpConditionalEvent >> #handlesAnnouncement:). In some situations
	the actual JavaScript event handler needs a specific setup. Subclasses should therefore
	override if necessary."

	self removeListenerFrom: anElement
]

{ #category : #announcing }
CpBaseEvent >> asAnnouncement [

	^ self
]

{ #category : #accessing }
CpBaseEvent >> currentTarget [

	self subclassResponsibility
]

{ #category : #dispatching }
CpBaseEvent >> dispatch [

	"Dispatch the receiver by announcing it through its element"

	(self currentTarget ifNil: [ ^ self ])
		announce: self
]

{ #category : #testing }
CpBaseEvent >> isActionKeyDown [

	"Answer whether the action key is down.
	The action key is platform specific: See CpActionKeyDown class comment."

	^ self modifiers allMask: CpActionKeyDown modifiers
]

{ #category : #testing }
CpBaseEvent >> isAltKeyDown [

	^ self modifiers allMask: CpAltKeyDown modifiers
]

{ #category : #testing }
CpBaseEvent >> isAnyModifierDown [

	^ self modifiers ~= 0
]

{ #category : #testing }
CpBaseEvent >> isCtrlKeyDown [

	^ self modifiers allMask: CpCtrlKeyDown modifiers
]

{ #category : #testing }
CpBaseEvent >> isMetaKeyDown [

	^ self modifiers allMask: CpMetaKeyDown modifiers
]

{ #category : #testing }
CpBaseEvent >> isNoModifierDown [

	^ self modifiers = 0
]

{ #category : #testing }
CpBaseEvent >> isShiftKeyDown [

	^ self modifiers allMask: CpShiftKeyDown modifiers
]

{ #category : #testing }
CpBaseEvent >> matchesModifierKeyDownCondition: aModifierKeyDownCondition [

	"Answer whether the specified key down condition matches (modifiers are equal)"

	^ aModifierKeyDownCondition matches: self
]

{ #category : #accessing }
CpBaseEvent >> modifiers [

	"Answer an Integer specifying the different modifiers pressed.
	Combine the following individual numbers:
		1 - alt
		2 - ctrl
		4 - meta
		8 - shift

	Implementation: The browser Key, Mouse, Touch and Gesture events support this as well as some
	Synthetic events, all others will answer 0."

	^ 0
]

{ #category : #announcing }
CpBaseEvent >> prepareForDelivery [

	"This method will be executed once before subscriptions delivery.
	If nobody subscribed on me this method will not be called.
	It allows to put some heavy initialization logic here. It will be executed only 
	if there is interest on me
	See Announcement >> #prepareForDelivery"
]
